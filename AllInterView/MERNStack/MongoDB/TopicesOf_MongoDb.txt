1. Introduction to MongoDB
What is MongoDB?
NoSQL, document-oriented database.
Stores data in flexible, JSON-like documents.
Comparison with SQL Databases
Schema-less vs. predefined schemas.
Collections vs. tables.
Documents vs. rows.

2. Core MongoDB Concepts
Database: Container for collections.
Collections: Groups of documents, akin to tables in SQL.
Documents: JSON-like records (BSON format).
Fields: Key-value pairs in a document.
Indexes: Structures to optimize query performance.
Replica Set: A group of MongoDB servers that maintain the same data set.
Sharding: Horizontal partitioning of data across servers.


3. Data Modeling in MongoDB
Document Model: Embedded documents and arrays.
Denormalization: Favor embedding documents over references to avoid JOINs.
Schema Design Patterns:
Embedding vs. Referencing.
Bucket Pattern, Attribute Pattern, and Polymorphic Schemas.


4. CRUD Operations
Create:
insertOne(): Inserts a single document.
insertMany(): Inserts multiple documents.

Read:
find(): Retrieves documents from a collection.
Query Filters: Equality, comparison operators ($eq, $gt, $lt), logical operators ($or, $and), and regex.

Update:
updateOne(), updateMany(): Modify documents.
$set, $inc, $unset update operators.
Upserts (update or insert).

Delete:
deleteOne(), deleteMany(): Remove documents.
Projections: Limiting fields returned by a query.
Sorting and Pagination: Using .sort() and .limit().


5. Indexes
Purpose: Speed up read queries.
Types of Indexes:
Single field index.
Compound index.
Multikey index (for arrays).
Text index (for text search).
Geospatial index.
Index Operations: createIndex(), dropIndex().
Indexing Best Practices: Only index fields used frequently in queries.


6. Aggregation Framework
Purpose: Advanced querying and data processing.
Stages in Aggregation Pipeline:
$match: Filters documents.
$group: Groups documents and performs operations like sum, avg.
$project: Reshapes documents.
$sort, $skip, $limit: Sorting and pagination.
$lookup: Joins collections (similar to SQL joins).
$unwind: Deconstructs arrays.


7. Replication
What is Replication?
High availability, disaster recovery.
Replica Sets:
Primary: Handles all write operations.
Secondaries: Replicate data from primary.
Arbiter: Participates in election but does not hold data.
Failover: Automatic election of a new primary in case of failure.


8. Sharding
What is Sharding?
Distributes data across multiple servers for horizontal scaling.
Shard Keys: Determines how data is partitioned.
Sharded Cluster:
Config Servers: Store metadata.
Shards: Actual data storage.
Query Router (mongos): Routes queries to appropriate shards.
Balancing: Redistributes data between shards automatically.


9. Transactions in MongoDB
Single Document Atomicity: MongoDB guarantees atomicity at the document level.
Multi-Document Transactions (Introduced in version 4.0):
Support for ACID transactions.
startTransaction(), commitTransaction(), abortTransaction().


10. MongoDB Performance Tuning
Schema Design Optimization: Denormalization, embedding documents.
Index Optimization: Proper index usage.
Query Optimization: Analyze using explain().
Read/Write Scaling:
Replication for read scaling.
Sharding for write scaling.



11. MongoDB Security
Authentication: Ensuring users are who they claim to be (SCRAM, x.509).
Authorization: Role-based access control (RBAC).
Encryption:
In-transit encryption (SSL/TLS).
Encryption at rest (with MongoDB Enterprise).
Auditing: Tracking and recording database events.
Backup and Restore: Using mongodump, mongorestore, and point-in-time backups.


12. MongoDB Backup and Restore
Backup Strategies:
Logical Backup: Using mongodump and mongorestore.
Physical Backup: Snapshot-based backups.
Cloud Backups: Managed MongoDB services (MongoDB Atlas) provide automated backups.
Restoring Data: Procedures for recovering data from backups.


13. MongoDB Tools
Mongo Shell: The interactive JavaScript interface.
MongoDB Compass: GUI for exploring and managing data.
mongodump and mongorestore: Tools for backing up and restoring.
mongoimport and mongoexport: Importing and exporting data in JSON/CSV.
mongostat and mongotop: Monitoring tools.


14. MongoDB Atlas
What is MongoDB Atlas?: Fully managed cloud database service.
Cluster Management: Scaling, monitoring, and backups.
Global Clusters: Data distribution across multiple geographic regions.
Serverless Instances: Automatically scales resources based on workload.


15. MongoDB Drivers and Integrations
Official Drivers: Available for many languages (Node.js, Python, Java, Go, etc.).
ODM/ORM:
Mongoose for Node.js.
PyMongo for Python.
Integration with Big Data Tools:
Spark Connector, Hadoop Integration.


16. Advanced MongoDB Features
GridFS: For storing large files (exceeding BSON document size limit of 16MB).
TTL Indexes: Automatically expire data.
Change Streams: Track changes to documents in real-time.
Capped Collections: Fixed-size collections that automatically overwrite oldest entries.
Time Series Collections: Optimized for time-series data.


17. MongoDB Cloud and Deployment
MongoDB Atlas: Cloud-hosted MongoDB.
Self-hosting MongoDB: Installation and configuration on various platforms.
Backup and Monitoring Services: Cloud monitoring, alerts, and performance analysis.


18. Best Practices
Schema Design: Favor embedding over referencing when possible.
Indexing: Only index frequently queried fields.
Sharding Considerations: Use a good shard key to avoid uneven distribution.
Monitoring: Use monitoring tools (Atlas, mongostat, mongotop) to track performance.


19. Version-Specific Features
MongoDB 4.x: Introduction of ACID transactions, retryable writes, etc.
MongoDB 5.x: Time-series collections, live resharding, and versioned API.


::::::::::::::::::::::::::::::::::::::::::::::: MongoDB playList ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

....... CRUD Operation :::::::::::::::::::


00:Mongose db DataTypes all ..............................
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  name: String,                    // String data type
  age: Number,                     // Number data type
  email: { type: String, unique: true },  // String with unique constraint
  isVerified: Boolean,             // Boolean data type
  createdAt: { type: Date, default: Date.now }, // Date with default value
  profilePicture: Buffer,          // Buffer data type for storing images
  posts: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Post' }], // ObjectId referencing another model
  meta: mongoose.Schema.Types.Mixed, // Mixed data type for dynamic content
  balance: mongoose.Schema.Types.Decimal128,  // High-precision numbers
  preferences: {                   // Map data type for key-value pairs
    type: Map,
    of: String
  }
});

const User = mongoose.model('User', userSchema);




1:: All Find Operation  In MongoDB.................

..Find all user
 db.dataall.find()
 db.dataall.find({qty:69})
db.dataall.find({qty:{$lte:36}}) // less then 36 show user adata
db.dataall.find().count() // number documents count
db.dataall.find().limit(3)
db.dataall.find({qty:{$gt:36}}) // Greater then 36 show user adata
db.dataall.find({qty:{$gt:36 , $lte:69}}) //less and greater 36 and 69
db.dataall.find().toArray() //show all elemnt
db.collectionName.find().pretty();
db.dataall.find({} , {name:1 , _id:0}) // only all name and remove all id

db.dataall.find().sort()({age:1 , name:1}) -- > asnding check  same and sort
db.dataall.find().sort()({age:-1}) -- > dsending
db.dataall.find().sort({age:1 , name:1}).forEach(x=>printjson(x)) // show all data 
db.dataall.find().sort()({age:1 , name:1}).skip(10) ///skip mena (10) man 
db.posts.find({}, {_id: 0, title: 1, date: 1})
db.dataall.findOne().name
db.dataall.findOne().isFunded
db.dataall.findOne().foundedOn
db.dataall.findOne().foundedoneTimeStamp

var cursor = db.users.find({ roll_no: { $gt: 30 } });
var dataSize = cursor.dataSize();
db.users.dataSize({})
db.users.totalSize()
db.users.storageSize()
db.users.totalIndexSize()
///
one:{
  [true , false]
}

db.dataall.find({'identy.hashADHARcARD:TRUE'})
//
....FindOne // check one User
...db.dataall.findOne({qty:69})


2:::: Insert  and insertMany ......................................


 db.dataall.insertOne({
  item: 'canvas',
  qty: 100,
  tags: ['cotton'],
  size: { h: 28, w: 35.5, uom: 'cm' }
});

////insertMany|||||||||||||||||||

db.clloectyy.insertMany([{_id:"A" , name:"jugal"},{_id:"b" , name:"kinka"}] , {ordered:false}) ///!SECTION

 db.collection.insertMany([
  {
    item: 'canvas',
    qty: 100,
    size: { h: 28, w: 35.5, uom: 'cm' },
    status: 'A'
  },
  {
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    item: 'mat',
    qty: 85,
    size: { h: 27.9, w: 35.5, uom: 'cm' },
    status: 'A'
  },

]);


3::::::: UpdateOne and UpdateMany .....................

2:::UpdateOne
db.dataall.updateOne({item:"mat"},{$set:{qty:0012}}) ///update qty 0012


3:::UpdateMany

db.dataall.updateMany({qty:25} , {$set:{qty:69}})///qty is 25 what update qty :69

db.dataall.updateMany({qty:{$gte:14}} , {$set:{isEligible:true}}) // add nuw Data and $get is graten then 14


|||||||||Update Advance ||||||||||

$inc
db.dataall.updateMany({} , {$inc:{qty:2}}) //$inc inment your age --> 20 $inc 22
db.dataall.updateMany({} , {$inc:{qty:2}}) //$inc inment your age --> 20 $inc 18


$min::db.dataall.updateMany({item:"jugal"} , {$min:{qty:30}})
$max::db.dataall.updateMany({item:"karan"} , {$max:{qty:30}})

...$mul //multiply
db.dataall.updateOne({item:"mouspad"} , {$mul:{qty:2}}) // 2 is multiply 

...$unset
db.dataall.updateOne({item:"mouspad"} , {$mul:{qty:2}}) ///remover qty 

...rename
db.dataall.updateOne({qty:87} , {$rename:{item:"jugtalsharma"}})
qty
87
jugtalsharma
"mat"
db.dataall.updateOne({} , {$rename:{item:"jugtalsharma"}}) // all user chaing

...$upset
db.dataall.updateOne({name:"coulu"} , {$set:{age:100}} , {upsert:true}) // name "coulu"in show and 

add upsert insert data 


|||||||||||Array  Update ||||||||
db.users.updateMany(
   { name: "amit" },
   { $push: { hobbies: ["youtuber" , "movies"] } }  //add new array  in name amit
)


db.users.updateMany(
   { name: "amit" },
   { $addToSet: { hobbies: ["youtuber" , "movies"] } }
) ///// same value not Push 


db.users.updateMany(
   { name: "amit" },
   { $pull: { hobbies: ["youtuber" , "movies"] } }
) ////Remove this array

db.users.updateMany(
   { name: "amit" },
   { $pop: { hobbies: 1 } } // last arrays delete  -1 first array delete
) ////Remove this array



4::: DeleteOne and DeleteMany .......................

..DeleteOne

db.dataall.deleteOne({item:"canvas"})


...DeleteMany

db.dataall.deleteMany({qty:10})


....DeleteAll 

db.dataall.deleteMany({}) // delteAllUser



5::: select column in MongoDB .................

db.stsudent.find({} , {name:1 , _id:0)} // only show name and remove id  .. 1 mean show and 0 mean remove 


6::: is MongoDb really Schemales ? .....................


7::DataTypes of Mongodb  ? ................................

Number :: insteger32 or numberLong64  or NumberDecimal 


8::: how to delete database in Monhodb ? .....................

1::show dbs
2::use Ones
3::db.alldata.find()
db.users.countDocuments()
db.createCollection("newUser")
db.url.renameCollection("fuckOf")
db.users.deleteMany({}) //  all uses deletes 
//Delete collection

db.dataall.drop()
db.users.getFullName()
ones.users

|||||||collection||||||||
db.dataall.drop()
db.users.getFullName()
db.users.countDocuments()
db.createCollection("newUser")
db.url.renameCollection("Of")
db.newUser.remove({ name: "John" })


mongodb+srv://jugal786:jugal786@cluster0.sgg8t.mongodb.net/ones?retryWrites=true&w=majority

















