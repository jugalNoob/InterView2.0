"Bit" is a basic unit of information in computing, representing a binary digit, either 0 or 1. Hereâ€™s a quick breakdown of how bits scale up into larger units of data:

1:::1 bit (binary digit) = smallest unit of data (0 or 1)
2:::8 bits = 1 byte (B)
3:::1024 bytes = 1 kilobyte (KB)
4::1024 kilobytes = 1 megabyte (MB)
5::1024 megabytes = 1 gigabyte (GB)
6::1024 gigabytes = 1 terabyte (TB)
7:::1024 terabytes = 1 petabyte (PB)
8::1024 petabytes = 1 exabyte (EB)
9::1024 exabytes = 1 zettabyte (ZB)
10:::1024 zettabytes = 1 yottabyte (YB)



UTF-8, UTF-16, and UTF-32 are different encoding formats used to represent Unicode characters in computer systems. They vary in terms of how many bytes they use to encode each character and how they handle different character sets. Hereâ€™s a breakdown of each:

1. UTF-8 (8-bit Unicode Transformation Format)
Encoding: Uses 1 to 4 bytes per character.
How it works:
For characters in the ASCII range (0â€“127), UTF-8 uses 1 byte (the same as ASCII).
For other characters, it uses 2, 3, or 4 bytes depending on the complexity of the character.
Advantages:
Efficient for Western languages (uses less space for ASCII characters).
Backward compatible with ASCII.
Widely used in the web and popular for file formats (like HTML, JSON, etc.).
Common Use: Websites, text files, and applications where storage space is a concern.
Example Encoding:

The character "A" (ASCII) = 0x41 (1 byte)
The character "â‚¬" (Euro sign) = 0xE2 0x82 0xAC (3 bytes)
2. UTF-16 (16-bit Unicode Transformation Format)
Encoding: Uses either 2 or 4 bytes per character.
How it works:
Most characters are encoded in 2 bytes (16 bits).
Characters outside the Basic Multilingual Plane (BMP) use 4 bytes (called "surrogate pairs").
Advantages:
More efficient for Asian languages (like Chinese, Japanese) that use more non-ASCII characters.
Disadvantages:
Less efficient for text dominated by ASCII characters (like English).
Handling surrogate pairs adds complexity.
Common Use: Internal text processing for systems like Windows or Java, and file formats like Microsoft Office.
Example Encoding:

The character "A" = 0x0041 (2 bytes)
The character "ðˆ" (Gothic letter) = 0xD800 0xDF48 (4 bytes)
3. UTF-32 (32-bit Unicode Transformation Format)
Encoding: Uses 4 bytes (32 bits) for every character.
How it works:
Every character, regardless of its Unicode code point, is represented with 4 bytes.
Advantages:
Very simple because every character is exactly 4 bytes, making it easy to index characters.
Disadvantages:
Memory inefficient for most texts, especially those that primarily use ASCII characters.
Common Use: Rarely used due to its inefficiency, but sometimes found in systems where fixed-width encoding is required.
Example Encoding:

The character "A" = 0x00000041 (4 bytes)
The character "ðˆ" = 0x00010348 (4 bytes)
Summary of Differences:
UTF-8: Variable-width (1â€“4 bytes), efficient for ASCII-heavy text, widely used on the web.
UTF-16: Variable-width (2â€“4 bytes), efficient for non-ASCII characters like those in Asian scripts, common in internal processing.
UTF-32: Fixed-width (4 bytes), simple but memory inefficient.





https://www.jstoolset.com/base64-decode   ---> Jugal sharma



What is Cryptography?
Difference Between Encoding,
Hashing & Cryptography
Types of Cryptography
How it works?
Cryptography tools
Hashing Tools
Encoding Tools




Q What is Cryptography?

Ans:: -->Cryptography is the practice and study of secure
 communication techniques used to protect
  information from unauthorized access. 
  It involves creating and deciphering codes 
  to ensure data confidentiality, integrity,
  and authentication.


  Difference Between Encoding, Hashing & Cryptography::::::::::::::::::::::::::::

Encoding:--> Encoding involves transforming data into another format 
using a scheme to ensure it's readable by a different system or application. 
It's not meant for security but for facilitating data transmission. Examples
 include Base64 and ASCII.

Hashing:----> Hashing is a one-way function that converts input data into a 
fixed-size string of characters, called a hash value or digest. It's used to 
verify data integrity and is irreversible. Even a small change in input data
 significantly alters the hash output.

Cryptography:----> Cryptography is a broader concept involving techniques like 
encryption and decryption to secure data during transmission or storage. Encryption
 scrambles data into ciphertext using algorithms and keys, which can be decrypted back
  to its original form by authorized parties.


  Types of Cryptography:::::::::::::::::::::::::::::::::::::::::::

Symmetric Cryptography:-----> Uses a single key for both encryption and decryption. 
Examples include AES (Advanced Encryption Standard) and DES (Data Encryption Standard).


Asymmetric Cryptography:---> Involves a pair of keys, public and private, where data
 encrypted with one key can only be decrypted by the other. Examples include RSA 
 and Elliptic Curve Cryptography.

Hashing Algorithms:---> Used for data integrity verification. Common hashing 
algorithms include MD5, SHA-1, SHA-256, etc.


How Cryptography Works: --------->
Cryptography operates through algorithms and keys. Encryption converts plaintext
 into ciphertext using an encryption algorithm and a key. Decryption uses the
  same or a corresponding  algorithm and key to convert the ciphertext back to plaintext.


  Cryptography Tools:::::::::::::::::::::::::::::::::::

OpenSSL:----> A robust open-source toolkit for SSL/TLS protocols and general-purpose
 cryptography.

GnuPG (GPG): Provides encryption and signing functions via various cryptographic
 protocols.
Crypto++: A free C++ class library of cryptographic algorithms and schemes.
Hashing Tools:

MD5 Hash Generator: Calculates the MD5 hash value of files or text inputs.

SHA-256 Online: Generates SHA-256 hash values for data input.

bcrypt: A password hashing function designed to be slow and resistant to brute-force attacks.
Encoding Tools:

Base64 Encoder/Decoder: Converts binary data to ASCII text and vice versa.
URL Encoder/Decoder: Encodes and decodes URLs to ensure safe transmission in web protocols.
UTF-8 Encoding/Decoding: Handles encoding and decoding of Unicode characters for text representation.



||||||||||||||||||Crypto Graphy With Code |||||||||||||||||||||||||||||||

///Crypto Encrypt and Decrypt


var CryptoJS = require("crypto-js");

// Encrypt
var ciphertext = CryptoJS.AES.encrypt('my message', 'secret key 123').toString();

// Decrypt
var bytes  = CryptoJS.AES.decrypt(ciphertext, 'secret key 123');
var originalText = bytes.toString(CryptoJS.enc.Utf8);

console.log(originalText); // 'my message'


|||||||||Hash Convert with Keys |||||||||||||||||||
Keyed-hash message authentication codes (HMAC) is a mechanism 
for message authentication using cryptographic hash functions.
import CryptoJS from 'crypto-js';
const message = 'Message';
const key = 'Key';
const hmac = CryptoJS.HmacSHA1(message, key);
const hmacString = hmac.toString(CryptoJS.enc.Base64);
console.log('HMAC-SHA1:', hmacString);

var hash = CryptoJS.HmacMD5("Message", "Secret Passphrase");
var hash = CryptoJS.HmacSHA1("Message", "Secret Passphrase");
var hash = CryptoJS.HmacSHA256("Message", "Secret Passphrase");
var hash = CryptoJS.HmacSHA512("Message", "Secret Passphrase");


var hmac = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, "Secret Passphrase");
hmac.update("Message Part 1");
hmac.update("Message Part 2");
hmac.update("Message Part 3");
â€‹
var hash = hmac.finalize();



||||||||||Convert to Hash With 256||||||||||

const message = 'Message to hash';

const hashedMessage = SHA256(message).toString();

console.log('SHA-256 Hash:', hashedMessage);

var sha256 = CryptoJS.algo.SHA256.create();
sha256.update("Message Part 1");
sha256.update("Message Part 2");
sha256.update("Message Part 3");â€‹
var hash = sha256.finalize();


|||||||||||||||PBKDF2 is a password-based key derivation function. In many applications of 
 cryptography, user security is ultimately dependent on a password, and because a
password usually can't be used directly as a cryptographic 
key, some processing is required. |||||||||||||

var salt = CryptoJS.lib.WordArray.random(128 / 8);
var key128Bits = CryptoJS.PBKDF2("Secret Passphrase", salt, {
  keySize: 128 / 32
});
var key256Bits = CryptoJS.PBKDF2("Secret Passphrase", salt, {
  keySize: 256 / 32
});
var key512Bits = CryptoJS.PBKDF2("Secret Passphrase", salt, {
  keySize: 512 / 32
});
var key512Bits1000Iterations = CryptoJS.PBKDF2("Secret Passphrase", salt, {
  keySize: 512 / 32,
  iterations: 1000
});



|||||||The Advanced Encryption Standard (AES) is a U.S. Federal Information Processing Standard (FIPS). It was selected after a 5-year
 process where 15 competing designs were evaluated. ||||||||||

 The Cipher Algorithms::::::


 var encrypted = CryptoJS.AES.encrypt("Message", "Secret Passphrase");
â€‹
var decrypted = CryptoJS.AES.decrypt(encrypted, "Secret Passphrase");

const message = 'Message';
const passphrase = 'Secret Passphrase';

const encrypted = CryptoJS.AES.encrypt(message, passphrase).toString();
console.log('Encrypted Message:', encrypted);

// Decrypt
const decrypted = CryptoJS.AES.decrypt(encrypted, passphrase).toString(CryptoJS.enc.Utf8);
console.log('Decrypted Message:', decrypted);




||||||||||||||||||DES is a previously dominant algorithm for encryption, and was published as an official Federal Information Processing Standard (FIPS). DES is now 
considered to be insecure due to the small key size.|||||||||||

var encrypted = CryptoJS.DES.encrypt("Message", "Secret Passphrase");
â€‹
var decrypted = CryptoJS.DES.decrypt(encrypted, "Secret Passphrase");

var encrypted = CryptoJS.TripleDES.encrypt("Message", "Secret Passphrase");
â€‹
var decrypted = CryptoJS.TripleDES.decrypt(encrypted, "Secret Passphrase");





|||||||||||||||||||||||Rabbit is a high-performance stream 
cipher and a finalist in the eSTREAM Portfolio. It is one of 
the four designs selected after a 3 1/2-year process where
 22 designs were evaluated.||||||||||||||||||||||||||||||||||

 var encrypted = CryptoJS.Rabbit.encrypt("Message", "Secret Passphrase");
â€‹
var decrypted = CryptoJS.Rabbit.decrypt(encrypted, "Secret Passphrase");




|||||||||||||||RC4, RC4Drop
RC4 is a widely-used stream cipher. It's used in popular protocols
 such as SSL and WEP. Although remarkable for its simplicity and speed, the
 algorithm's history doesn't inspire confidence in its security.


 var encrypted = CryptoJS.RC4.encrypt("Message", "Secret Passphrase");
 var decrypted = CryptoJS.RC4.decrypt(encrypted, "Secret Passphrase");


 var encrypted = CryptoJS.RC4Drop.encrypt("Message", "Secret Passphrase");
 â€‹
 var encrypted = CryptoJS.RC4Drop.encrypt("Message", "Secret Passphrase", {
   drop: 3072 / 4
 });
 â€‹
 var decrypted = CryptoJS.RC4Drop.decrypt(encrypted, "Secret Passphrase", {
   drop: 3072 / 4
 });





 ||||||||Custom Key and IV |||||||||||||||||||||||||

 var key = CryptoJS.enc.Hex.parse("000102030405060708090a0b0c0d0e0f");

var iv = CryptoJS.enc.Hex.parse("101112131415161718191a1b1c1d1e1f");
â€‹
var encrypted = CryptoJS.AES.encrypt("Message", key, { iv: iv });


import React, { useEffect } from 'react';
import CryptoJS from 'crypto-js';

const MyComponent = () => {
  useEffect(() => {
    // Properties from the encrypted object
    const encryptedData = {
      key: CryptoJS.enc.Hex.parse("74eb593087a982e2a6f5dded54ecd96d1fd0f3d44a58728cdcd40c55227522223"),
      iv: CryptoJS.enc.Hex.parse("7781157e2629b094f0e3dd48c4d786115"),
      salt: CryptoJS.enc.Hex.parse("7a25f9132ec6a8b34"),
      ciphertext: CryptoJS.enc.Hex.parse("73e54154a15d1beeb509d9e12f1e462a0")
    };
    // Passphrase used during encryption
    const passphrase = "Secret Passphrase";

    // Create an object compatible with decryption
    const decryptionObject = {
      ciphertext: encryptedData.ciphertext,
      key: encryptedData.key,
      iv: encryptedData.iv,
      salt: encryptedData.salt
    };

    // Decrypt the data
    const decrypted = CryptoJS.AES.decrypt(decryptionObject, passphrase).toString(CryptoJS.enc.Utf8);

    console.log('Decrypted Message:', decrypted);
  }, []);

  return (
    <div>
      {/* Your component JSX */}
    </div>
  );
};

export default MyComponent;



|||||||||||||||||||Base in CryptoGraphy |||||||||||||||||||||||||||||
import React, { useEffect } from 'react';
import CryptoJS from 'crypto-js';

    // Base64 Encoding/Decoding
    const base64String = "SGVsbG8sIFdvcmxkIQ==";
    const base64Words = CryptoJS.enc.Base64.parse(base64String);
    const base64Decoded = CryptoJS.enc.Base64.stringify(base64Words);

    console.log('Base64 Encoded:', base64String);
    console.log('Base64 Decoded:', base64Decoded);

    // Latin1 Encoding/Decoding
    const latin1String = "Hello, World!";
    const latin1Words = CryptoJS.enc.Latin1.parse(latin1String);
    const latin1Encoded = CryptoJS.enc.Latin1.stringify(latin1Words);

    console.log('Latin1 Encoded:', latin1String);
    console.log('Latin1 Decoded:', latin1Encoded);

    // Hex Encoding/Decoding
    const hexString = "48656c6c6f2c20576f726c6421";
    const hexWords = CryptoJS.enc.Hex.parse(hexString);
    const hexEncoded = CryptoJS.enc.Hex.stringify(hexWords);

    console.log('Hex Encoded:', hexString);
    console.log('Hex Decoded:', hexEncoded);

    // UTF-8 Encoding/Decoding
    const utf8String = "ð”­¢";
    const utf8Words = CryptoJS.enc.Utf8.parse(utf8String);
    const utf8Encoded = CryptoJS.enc.Utf8.stringify(utf8Words);

    console.log('UTF-8 Encoded:', utf8String);
    console.log('UTF-8 Decoded:', utf8Encoded);

    // UTF-16 Encoding/Decoding
    const utf16String = "Hello, World!";
    const utf16Words = CryptoJS.enc.Utf16.parse(utf16String);
    const utf16Encoded = CryptoJS.enc.Utf16.stringify(utf16Words);

    console.log('UTF-16 Encoded:', utf16String);
    console.log('UTF-16 Decoded:', utf16Encoded);

    // UTF-16LE Encoding/Decoding
    const utf16LEString = "Hello, World!";
    const utf16LEWords = CryptoJS.enc.Utf16LE.parse(utf16LEString);
    const utf16LEEncoded = CryptoJS.enc.Utf16LE.stringify(utf16LEWords);

    console.log('UTF-16LE Encoded:', utf16LEString);
    console.log('UTF-16LE Decoded:', utf16LEEncoded);


    var words = CryptoJS.enc.Base64.parse("SGVsbG8sIFdvcmxkIQ==");
â€‹
var base64 = CryptoJS.enc.Base64.stringify(words);
â€‹
var words = CryptoJS.enc.Latin1.parse("Hello, World!");
â€‹
var latin1 = CryptoJS.enc.Latin1.stringify(words);
â€‹
var words = CryptoJS.enc.Hex.parse("48656c6c6f2c20576f726c6421");
â€‹
var hex = CryptoJS.enc.Hex.stringify(words);
â€‹
var words = CryptoJS.enc.Utf8.parse("ð”­¢");
â€‹
var utf8 = CryptoJS.enc.Utf8.stringify(words);
â€‹
var words = CryptoJS.enc.Utf16.parse("Hello, World!");
â€‹
var utf16 = CryptoJS.enc.Utf16.stringify(words);
â€‹
var words = CryptoJS.enc.Utf16LE.parse("Hello, World!");
â€‹
var utf16 = CryptoJS.enc.Utf16LE.stringify(words);
